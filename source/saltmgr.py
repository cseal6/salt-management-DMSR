# Main script for salt-management-DMSR.
import argparse
import os
import pickle
import RefuelCore
import genericserpentinput
import pickle
import time
import copy
import scipy.optimize
import subprocess

# First read command line input
parser = argparse.ArgumentParser(description=
    'saltmgr: an interface to Serpent 2 for molten salt reactor depletion.',
    epilog=
    'feel free to email Gavin Ridley at gridley@vols.utk.edu for any help')

# input file for this script
parser.add_argument('inpfile', metavar='f',type=str, nargs=1,
    help='name of the saltmgr input file')

# output directory for SerpentInputFile objects at each depletion step
parser.add_argument('--outdir',dest='outputdirectory',type=str, nargs=1,
    help='name of output directory',default='inputfileslog')

args = parser.parse_args()
saltmgrinput = args.inpfile # name of saltmgr input file
outdir = args.outputdirectory
originaldir = os.getcwd() # get current working dir

# clear old output directory <>? y or n?
if outdir in os.listdir('.'):
    print 'would you like to delete the old output directory, {}?'.format(outdir)
    response = ''
    while response not in ['y','Y','n','N']:
        response=input('y/n')
    if response in ['N','n']:
        print "Bye."
        quit()
    elif response in ['y','Y']:
        print 'forreal though? press enter to continue, ctrl-C to exit.'
        input()
        print 'deleting old output directory'
    else:
        raise Exception('I SAID Y OR N, HOW DID YOU BREAK THIS')

# now read from the input file.
inpfile = open(saltmgrinput)

# init some variables that are necessary for running
optdict = dict.fromkeys(['maintenance','keffbounds','refuel','absorber','core',
                         'maxiter', 'constflows','fuel','runsettings','maxBurnTime',
                         'burnIncrement']) #contains all options

otheropts = [] # all other options

#some options will be in the form of a list. init.
optdict['maintenance']=[]
optdict['constflows'] =[]
optdict['runsettings']=dict.fromkeys('PPN','queue','num_nodes')

for line in inpfile:
    
    # split line
    sline = line.split()

    # now go through all options
    if sline[0] == 'set':

        # this is for setting options
        if sline[1]=='refuel':

            #sets the refuel material. is it just more highly enriched fuel, or the fuel?
            if sline[2] == 'moreEnrichedFuel':

                # should be enrichment of refuel mat
                optdict['refuel']=('moreEnrichedFuel',sline[3]) 

            elif sline[2] == 'sameAsFuel':
                
                #this implies making a copy of the fuel material and renaming
                optdict['refuel']=('sameAsFuel', -1.0)

        elif sline[1]=='fuel':

            # save what the name of the fuel material is
            optdict['fuel']=sline[2]

        # these next 3 are for PPN, queue, number of nodes, etc
        elif sline[1] == 'PPN':

            optdict['runsettings']['PPN'] = sline[2]

        elif sline[1] == 'queue':

            optdict['runsettings']['queue'] = sline[2]

        elif sline[1] == 'num_nodes':

            optdict['runsettings']['num_nodes'] = sline[2]



    elif '<' in sline and 'keff' in sline:

        # set keff bounds
        optdict['keffbounds'] = None,None
        optdict['keffbounds'][0] = float(sline[0])
        optdict['keffbounds'][1] = float(sline[2])


    elif sline[0] == 'maintain':

        # this will be a salt maintenance entry.
        quantity = sline[1] #quantity to maintain over depletion

        # make sure it is a supported quantity
        assert quantity in ['fluorideExcess', 'concentration']

        # now save this maintenance request

    elif sline[0] == 'core':

        # should the core be generated by the core writer, or
        # should it be read in from a serpent input file?
        # need to be sure to watch for 'include' statements in the file

        if sline[1] == 'serpentInput':
            
            # name of serpent input file to read from
            optdict['core']=('serpentInput', sline[2])

            #check input exists
            if optdict['core'][1] not in os.listdir('.'):
                raise Exception('input file {} not found in current directory'.format(
                    optdict['core'][1]))

            # the serpent input will later be actually read in

        elif sline[1] == 'DMSR':

            # grab input params
            coresize = sline[2]
            pitch    = sline[3]
            saltfrac = sline[4]
            initenrich = sline[5]
            salt_type = sline[6]

            # save it
            # storing data in tuples is cool i guess
            optdict['core']=('DMSR',(coresize,pitch,saltfrac))

            print 'writing {} meter DMSR core with {} cm pitch and 
                    salt fraction of {}'.format(coresize, pitch,saltfrac)

        elif sline[1] == 'oldObject':

            # this option reads a pickled object of either RefuelCore.SerpentInputFile
            # type or of the genericInput type

            if sline[2] not in os.listdir('.'):

                raise Exception('old core obj {} not found in current dir'.format(
                    sline[2])

            # save it
            optdict['core']=='oldObject',sline[2]


    elif line !='\n':
        raise Exception('unknown keyword: {}'.format(line)
        

# check input
if None in optdict.values():
    raise Exception('not all required options were set')

# Now take that, and deplete!
# load a serpent input file, or generate one from the core writer?
if optdict['core'][0] == 'serpentInputFile':
   
    # first off, create a new generic serpent input file object
    myCore=genericserpentinput.genericInput(num_nodes=optdict['runsettings']['num_nodes']
                                              ,PPN=optdict['runsettings']['PPN']
                                              queue=['runsettings']['queue'])

    # try to read in the serpent input file and save all of its options, materials, etc
    serpentInpFile = open(optdict['core'][1], 'r')

    # the first thing I'd like to do is search for all of the materials and their
    # names.
    for line in serpentInpFile:

        # split the line
        sline = line.split()

        # check if there is a material
        if sline[0] == 'mat':

            # append all materials to the core object
            myCore.materials.append(SerpentMaterial('serpentoutput',
                                    materialname=sline[1],
                                    materialfile=optdict['core'][1]))

            # is it fuel? this is what really matters.
            if sline[1] == optdict['fuel']:

                # save pointer to the fuel material
                fuel = myCore.materials[-1]

            # is it blanket? also matters a good bit.

        elif sline[0] == 'include':

            # then, also look for any "include" statements in the input. 
            # these must be copied for any test refuel cases ran.

            self.includefiles.append(sline[1])


        elif sline[0]=='set' and sline[1]=='pop':

            # change the kcode settings
            myCore.ChangeKcodeSettings(sline[2],sline[3],sline[4])


        else:

            # just add on the rest to the input file
            # the hope here is that the user used "set pop"
            self.otheropts.append( line )

    # and close the original input file
    serpentInpFile.close()

elif optdict['core'][0] == 'DMSR':

    # create a new DMSR from Dr. Chvala's core writer
    myCore = RefuelCore.SerpentInputFile(core_size=coresize,
                                        salt_type=,
                                        case=1,
                                        salt_fraction=saltfrac,
                                        pitch=pitch,
                                        initial_enrichment=initenrich,
                                        num_nodes=optdict['runsettings']['num_nodes'],
                                        PPN=optdict['runsettings']['PPN'],
                                        queue=optdict['runsettings']['queue'] )

elif optdict['core'][0] == 'oldObject':

    # this simply reads in an old SerpentInputFile or genericInput

    myCore = pickle.load(filehandle)

# --- initialization ---

burnttime = 0
show_new_Umetal_addition_model_difference=True
refuelrates=[] #empty list
refuelrate=initialguessrefuelrate

#--------------
#temporary:
refuelrate=0.40774835852993285
#---------------

absorberadditionrates=[]
Umetaladditionrates=[]
absorberadditionrate=0.0
Umetaladditionrate=0.0

burnsteps=[]
material_densities=[]
successful_keffs=[]
successful_refuelrates=[]
successful_absorberrates=[]
successful_Umetaladditionrates=[]
absorbertestrhos=[]
refueltestrhos=[]
attempted_absorber_rates=[]
attempted_refuel_rates=[]
absorber_sigmas=[]
refuel_sigmas=[]

#---------------------------#

starttime=time.asctime()
print "Starting the refuelling simulation at {0}".format(starttime)
print "First input file is being refuelled at {0} ccm/s.".format(initialguessrefuelrate)


iternum=0 #keeps track of number of iterations needed to solve for refuel rate in a given depletion step

#create a directory for storing InputFile pickles too. yum
if outdir not in listdir('.'):
    subprocess.call(['mkdir', outdir])

# BURN BABY BURN
while burnttime < maxburntime:
